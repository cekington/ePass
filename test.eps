type bin = +{ 'e : 1, 'b0 : bin, 'b1 : bin }
      type list = +{ 'nil : 1, 'cons : bin * list }
      
      proc nil (r : list) [] = send r 'nil ; send r ()
      proc cons (r : list) [x : bin, l : list] =
        send r 'cons; send r x; fwd r l
      
      proc append (r : list) [l : list, k : list] =
        recv l ('nil => recv l (() => fwd r k)
               |'cons => recv l (x => 
                  send r 'cons; 
                  send r x; 
                  call append (r) [l, k]))
      
      proc reverse (r : list) [l : list] =
        recv l (
          'nil => send r 'nil; fwd r l
        | 'cons => recv l (x => 
            empty : list <- call nil (empty) [];
            lx : list <- call cons (lx) [x, empty];
            lrev : list <- call reverse (lrev) [l];
            call append (r) [lrev, lx]
          )  
        )

      type iterator = &{ 'next : bin -o (bin * iterator) , 'done : 1 }

      proc map (r : list) [iter : iterator, l : list] = 
        recv l (
          'nil => send iter 'done; 
            recv iter (() =>  
              send r 'nil; 
              fwd r l
            )
        | 'cons => send iter 'next; 
            recv l (x => 
              send iter x; 
              recv iter (xx =>
                send r 'cons;
                send r xx;
                call map (r) [iter, l]
              )
            ) 
        )
      
      proc isucc (i : iterator) [] = 
        recv i ( 
          'next => recv i (x => 
            y : bin <- call succ (y) [x];
            send i y;
            call isucc (i) []
          )
        | 'done => send i ()
        )

      proc succ (y : bin) [x : bin] =
      recv x ( 'e => recv x (() => send y 'b1 ; send y 'e ; send y ())
              | 'b0 => send y 'b1 ; fwd y x
              | 'b1 => send y 'b0 ; call succ (y) [x])