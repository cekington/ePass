type msg = +{'f : msg, 'p : msg, 'eof : 1}

proc dup_msg (x : msg * msg) [y : msg] =
    recv y (
        'f => x' : msg * msg <- call dup_msg (x') [y];
        recv x' (x1' => 
            x1 : msg <- (send x1 'f; fwd x1 x1');
            send x x1; send x 'f; fwd x x'
        )
      | 'p => x' : msg * msg <- call dup_msg (x') [y];
        recv x' (x1' => 
            x1 : msg <- (send x1 'p; fwd x1 x1');
            send x x1; send x 'p; fwd x x'
        )
      | 'eof => recv y (() =>
            x1 : msg <- (send x1 'eof; send x1 ());
            send x x1; send x 'eof; send x ()
      )
    )

proc test_dup_msg (x : msg * msg) [] =
    org : msg <- (send org 'f; send org 'p; send org 'eof; send org ());
    call dup_msg (x) [org]

exnproc server_good (x : msg) [y : msg] = 
    send x 'f; fwd x y

exnproc server_bad (x : msg) [y : msg] =
    raise(cancel x, cancel y)

exnproc server (x : msg) [y : msg] =
    call server_good (x) [y]

proc client (output : msg) [input : msg] =
    input_dup : msg * msg <- call dup_msg (input_dup) [input];
    recv input_dup (input_1 => 
        y : msg <<- call server (y) [input_1] catch call client () [input_dup]
    )